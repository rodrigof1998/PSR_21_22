#!/usr/bin/env python3
import math
from copy import copy
import copy
import rospy
import tf2_geometry_msgs
import tf2_ros
from geometry_msgs.msg import Twist, PoseStamped


class Driver:
    def __init__(self):

        self.goal = PoseStamped()
        self.goal_active = False
        self.angle = 0
        self.speed = 0

        self.name = rospy.get_name()
        self.name = self.name.strip('/')    # remove initial /
        #self.name = 'p_rferreira'
        print('My player name is ' + self.name)

        self.publisher_command = rospy.Publisher('/' + self.name+'/cmd_vel', Twist, queue_size=1)

        self.tf_buffer = tf2_ros.Buffer()
        self.listener = tf2_ros.TransformListener(self.tf_buffer)

        self.timer = rospy.Timer(rospy.Duration(0.1), self.sendCommandCallback)

        self.goal_subscriber = rospy.Subscriber("/move_base_simple/goal", PoseStamped, self.goalReceivedCallback)

    def goalReceivedCallback(self, msg):
        target_frame = self.name + '/odom'
        try:
            self.goal = self.tf_buffer.transform(msg, target_frame, rospy.Duration(1))
            self.goal_active = True
            rospy.logwarn('Setting new goal')
        except(tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
            self.goal_active = False
            rospy.logerr('Could not transform goal from ' + msg.header.frame_id + ' to ' + target_frame+'. Will ignore this goal.')

        # print('Received new goal')
        # self.goal = copy(msg)   # store goal

    def driveStraight(self, minimum_speed=0.1, maximum_speed=2):
        goal_copy = copy.deepcopy(self.goal)
        goal_copy.header.stamp = rospy.Time.now()

        # goal_tf = tf2_geometry_msgs.PoseStamped()
        # goal_tf.header.stamp = rospy.Time.now()
        # goal_tf.header.frame_id = self.goal.header.frame_id

        goal_in_base_link = self.tf_buffer.transform(goal_copy, self.name + '/base_footprint',rospy.Duration(1))
        x = goal_in_base_link.pose.position.x
        y = goal_in_base_link.pose.position.y
        self.angle = math.atan2(y, x)
        print('angle: ' + str(self.angle))

        if self.angle > -0.35 and self.angle < 0.35:
            distance_to_goal = math.sqrt(x**2 + y**2)
            self.speed = max(minimum_speed, 0.8 * distance_to_goal)
            self.speed = min(maximum_speed, self.speed)
        else:
            self.speed = max(minimum_speed, self.speed-0.05)
        print('speed: ' + str(self.speed))

    def sendCommandCallback(self, event):
        print('Sending twist command')
        if not self.goal_active:
            self.speed = 0
            self.angle = 0
        else:
            self.driveStraight()

        twist = Twist()
        twist.linear.x = self.speed
        twist.angular.z = self.angle

        self.publisher_command.publish(twist)

def main():
    # -------------------------------
    # INITIALIZATION
    # -------------------------------

    rospy.init_node('p_rferreira_driver')

    driver = Driver()

    rospy.spin()

    # while not rospy.is_shutdown():
    #
    #     # create a message to send
    #

        # try:
        #     trans = tfBuffer.lookup_transform('mercury', 'moon', rospy.Time())
        #     distance = math.sqrt(trans.transform.translation.x**2 + trans.transform.translation.y**2)
        #     rospy.loginfo('Distance from mercury to moon is ' + str(distance))
        # except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
        #     rospy.logwarn('Could not find transformation from mercury to moon')
        #     rate.sleep()
        #     continue
        # rate.sleep()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass